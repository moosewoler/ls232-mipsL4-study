% Permission to make digital/hard copy of part or all of this work for
% personal or classroom use is granted without fee provided that copies
% are not made or distributed for profit or commercial advantage, the
% copyright notice, the title of the publication and its date appear, and
% notice is given that copying is by permission of the authors. To copy
% otherwise, to republish, to post on servers, or to redistribute to lists
% requires prior specific permission and/or a fee.
%
% Copyright (C) 1998 by Gernot Heiser, The University of New South Wales.


% L4 user manual IPC chapter
% Author: Alan Au
% Created On: 3 December 1997
% Last Modified: 3 Septermber 1998

\chapter{\label{c:ipc}L4 IPC}


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{IPC Overview}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Message passing is the basic IPC mechanism in L4. It allows L4 threads
to communicate via messages.

All L4 IPC is synchronous and unbuffered. Synchronous IPC requires an
agreement between both the sender and the receiver. The main
implications of this agreement is that the receiver is expecting an
IPC and provides the necessary buffers. If either the sender or the
receiver is not ready, then the other party must wait. Unbuffered IPC
reduces the amount of copying involved and is thus the key to high
performance IPC.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{L4 IPC Messages}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Message Data Types}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:msgdata}

Data can be transferred in three ways using L4 IPC.

\begin{enumerate}

\item In-line by-value data. A limited amount of such data is passed
  directly in registers (first 8 words in MIPS R4k) with any remainder
  in a message buffer.

\item Strings. Arbitrary out-of-line buffers which are copied to the
  receiver.
        
\item Virtual memory mappings (by-reference data). Data transfer via
  mappings is described by \emph{flex-pages (fpages)}. Alternatively,
  virtual memory can be granted: mapped to the receiver and unmapped
  from the sender simultaneously.

\end{enumerate}

Figure~\ref{fig:msgdata} illustrates the difference between in-line
by-value data and strings.

\begin{figure}[htb]
\centering
\mbox{\subfigure[In-Line]
        {\epsfig{figure=eps/inline_data.eps,width=.32\textwidth}}\quad
      \subfigure[String]
        {\epsfig{figure=eps/string_data.eps,width=.22\textwidth}}}
\caption{In-line Versus String Data}
\label{fig:msgdata}
\end{figure}

A \label{s:fpages}flex-page is a contiguous region of virtual address
space. A flex-page has the following properties.

\begin{itemize}
        
\item Of size \(2^{s}\) bytes. The smallest size allowed for any fpage
  is the hardware page size.

\item Base address aligned to \(2^{s}\) (\(base~address \bmod~2^{s} =
  0 \)).

\item Contains all the \emph{mapped} pages within the region described
  by the flex-page. That is, those pages which belong to the specified
  region \emph{and} which have been mapped into the sender's virtual
  address space. (For convenience, call these the valid pages).

\end{itemize}

Fpages are required for mapping and granting virtual memory. Fpages
are specified by the mapper and received by the mappee\footnote{The
  terms \emph{mapper} and \emph{mappee} will be used in both mapping
  and granting contexts.} as part of an IPC message. For each fpage
successfully received, the valid pages within that fpage become part
of (mapped or granted to) the receiver's address space.

\begin{figure}[htb]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/fpage.eps}
\end{center}
\caption{Flex-page}
\label{fig:fpage}
\end{figure}

An fpage is specified by providing the values $b$ and $s$. The fpage
is then defined to be the region [$b \times 2^{s}$, $(b + 1) \times
2^{s}$]. In addition, a hot-spot, $h$, is also required for the sender
if the sender and receiver specify fpages of different sizes. In such
a case, the hot-spot specification is used to determine how the
mapping between the two different size fpages occurs: If \(2^s\) is
the size of the larger, and \(2^t\) the size of the smaller fpage,
then the larger fpage can be thought of as being tiled by \(2^{s-t}\)
fpages of the smaller size. One of these is uniquely identified as
containing the hot spot address (mod \(2^s\)). This is the fpage which
will actually be mapped/granted.

Figure~\ref{fig:fpmap} gives two examples of mappings which involve
different fpage sizes. The figure also illustrates the fact that the
receiver's fpage allows the receiver to specify the window where
mappings are permitted to occur (greater security).

\begin{figure}[htb]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/fpmap.eps}
\end{center}
\caption{Fpage Mapping Example}
\label{fig:fpmap}
\end{figure}

A precise definition of the intuitive description above is now given
for completeness. If the sender defines its fpage as $b$, $s$, $h$ and
the receiver defines its fpage as $b'$, $s'$ then the mappings for the
three situations would be:

\begin{description}

\item[$s = s'$:] mapping is $b \times 2^{s} \mapsto b' \times 2^{s}$
  \\ hot spot is not used

\item[$s < s'$:] mapping is $b \times 2^{s} \mapsto b'_{[63, s]}
  h_{[s' - 1, s]}0_{(s)}$ \\ the sender's fpage is aligned around the
  hot-spot

\item[$s > s'$:] mapping is $b_{[63, s]}h_{[s - 1, s']}0_{(s')}
  \mapsto b' \times 2^{s'}$\\ the receiver's fpage is aligned around
  the hot-spot

\end{description}

As an explanation of the notation above, $b'_{[63, s']}h_{[s' - 1,
  s]}0_{(s)}$ represents the bit address formed by concatenating
together, in the given order:

\begin{itemize}

\item Bits 63 through to bit $s'$ (inclusive) of $b$.
        
\item Bits $s' - 1$ through to bit $s$ (inclusive) of $h$.

\item $s$ number of zeroes.

\end{itemize}   

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Messages}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:messages}

The message formats shown in this section are for L4/MIPS. On other
platforms they are mostly very similar.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Message Descriptors}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

A message descriptor is a pointer to the start of a message
buffer\footnote{See following description of a long message.} or
indication that the IPC is purely register based. There are two types
of message descriptors: one for sending and one for receiving IPC.

The format of the send message descriptor is:

\begin{tabular}{ll} 
\hspace*{100pt}&\\[\Up] 
% 
&
\cbox{snd msg/4}{62}{30}\abox{m}{1}\abox{d}{1}\\[20pt]
% 
\end{tabular}

A non-zero message descriptor address (\emph{snd msg}) is interpreted
as the start address of the sender's message buffer. A zero value
indicates a purely register based IPC. Setting the $m$-bit indicates
that the IPC includes mappings (i.e.\ fpages are present followed
possibly by by-value data). A zero value for the $m$-bit indicates
that the message contains only by-value data and no fpages. Setting
the $d$-bit indicates that the IPC is deceiving.

The format of the receive descriptor is similar:

\begin{tabular}{ll} 
\hspace*{100pt}&\\[\Up] 
% 
&
\cbox{rcv msg/4}{62}{30}\abox{m}{1}\abox{o}{1}\\[20pt]
% 
\end{tabular}

If the $m$-bit is not set, the message descriptor address (\emph{rcv
  msg}) is interpreted as the start address of the receiver's message
buffer, which may contain a receive fpage, indicating the caller's
willingness to receive mappings or grants. Setting the $m$-bit
indicates that the caller is willing to accept fpage mappings but no
long message, and has supplied the receive fpage directly as the
\emph{rcv msg} parameter (there is no message buffer in this case).
Setting the $o$-bit will allow a receive from any sender (open wait)
while a zero value for the $o$-bit allows receiving only from the
specified sender.

Note that the the message descriptor addresses have had their least
significant two bits removed. These two bits are not needed as the
message buffer must be word aligned.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Short And Long Messages}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Every successful IPC operation will always copy at least eight dwords
(for MIPS) to the receiver. These eight dwords contain the first 64
bytes of a message's in-line data\footnote{Section~\ref{sec:msgdata}
  describes the two types of in-line data: by-value data and fpage
  descriptors.} and is referred to as the \emph{short} part of the
message. The short message is transferred via registers (\textbf{s0}
\dots \textbf{s7} on MIPS R4k) and its format is:

\vspace{15pt}
\noindent\begin{tabular}{lcr} 
\hspace*{100pt}
s7 & \abox{by-value data}{32} & \\
\hspace*{100pt} \vdots & \vdots & \\
\hspace*{100pt} s0 & \abox{fpage descriptors}{32} &
\end{tabular}

The presence of fpages is indicated by setting the $m$-bit in the
message descriptor. Processing of fpages starts at the beginning of
the message and continues until an invalid fpage is encountered. This
last dword and the remainder of the in-line data is interpreted as
by-value data.

The \emph{long} part of the message is optional and its presence is
indicated by the message descriptor (\emph{snd msg/recv msg}). If
present, it is a dword-aligned memory buffer pointed to by a
\emph{message descriptor}. The buffer contains a three dword message
header, followed by a number of mwords (the rest of the in-line data),
followed by a number of string dopes. The number of mwords (in 64-bit
dwords, excluding those copied in registers) and string dopes is
specified in the message header.

The format for the long part of the message is:

 \vspace{15pt}
\noindent\begin{tabular}{lcr} 
 \hspace*{100pt}  & \abox{string dopes}{32} & +$x$\\
                  & \abox{mwords (fpage descriptors + by-value data)}{32} & +24\\
message:          & \abox{msg header}{32} & +0\\
\end{tabular}

The value of $x$ is determined by the number of mwords in the message
as specified in the \emph{size dope} of the message header.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Message Header}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

The message header describes the format of the long message.

 \vspace{15pt}
\noindent\begin{tabular}{lcr} 
msg snd dope:  &
          \cbox{0}{32}{9}\cbox{dwords}{19}{10}\cbox{strings}{5}{5}\cbox{\undef}{8}{8} & +16\\
msg size dope:  &
          \cbox{0}{32}{9}\cbox{dwords}{19}{10}\cbox{strings}{5}{5}\cbox{\undef}{8}{8} & +8\\
msg rcv fpage option: & \cbox{fpage}{64}{32} & +0\\
\end{tabular}

The \emph{size dope} defines the size of the dword buffer, in words,
(and hence the offset of the string dopes from the end of the header),
and the number of string dopes in the long message.

The \emph{send dope} specifies how many dwords and strings are
actually to be sent. (Specifying send dope values less than the size
dope values makes sense when the caller is willing to receive more
data than it is sending.)

The \emph{receive fpage} describes the address range in which the
caller is willing to accept fpage mappings or grants in the receive
part (if any) of the IPC. As described in section~\ref{sec:msgdata},
an fpage region is defined by providing its base address, $b$ and size
exponent, $s$. Note that the hot-spot, $h$, is provided by the sender
and hence not required as part of the receive fpage.

The fpage format is:  

\vspace{12pt} 
 
\begin{tabular}{ll} 
\hspace*{80pt}&\\[\Up] 
% 
fpage$(b,2^{s})$ &
\cbox{$b/4096$}{52}{20}\bbox{0}{3}\cbox{$s$}{7}{7}\abox{\undef{}}{1}\abox{\undef{}}{1}\\[20pt]
% 
\end{tabular} 

The base address can be given as $b/4096$ rather than just $b$ because
fpages needs to be aligned to at least the hardware page size ($4096$
or $2^{12}$ bytes).

A special case of an fpage is one that specifies the complete user
address space (i.e. address space with base 0 and size $2^{64} - K$,
where $K$ is the size of the kernel area).

\vspace{12pt} 
 
\begin{tabular}{ll} 
\hspace*{80pt}&\\[\Up] 
% 
fpage$(0,2^{64} - K)$ &
\cbox{0}{52}{20}\bbox{0}{3}\cbox{64}{7}{7}\abox{\undef{}}{1}\abox{\undef{}}{1}\\[20pt]
% 
\end{tabular} 

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Message mwords}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

The (possibly zero) message mwords follow directly after the message
header and contain the rest of the in-line data remaining after the
short message. This in-line data is made up of a number (again,
possibly zero) of fpage descriptors followed by by-value data.

 \vspace{15pt}
\noindent\begin{tabular}{lcr} 
\hspace*{100pt} & \vdots & \\
& \abox{by-value data}{32} & \\
mwords:   & \abox{fpage descriptors}{32} &\\
& \vdots &
\end{tabular}

Fpage descriptors are expected in memory (the long message) only if
the $m$-bit is set in the message descriptor and all register data
(the entire short message) consists of valid fpages. These fpage
descriptors (together with those in the short message) are provided by
the sender for memory mapping purposes. The format of an fpage
descriptor is:

\vspace{12pt} 

\label{s:w-bit}
\begin{tabular}{ll} 
\hspace*{80pt}&\\[\Up] 
% 
snd fpage: &
\cbox{$b/4096$}{52}{20}\bbox{0}{3}\cbox{$s$}{7}{7}\abox{w}{1}\abox{g}{1}\\
%
hot spot: &\cbox{snd base}{64}{32} 
\end{tabular} 

The \emph{snd fpage} is in the same format as the \emph{receive fpage}
in the message header except the least significant two bits are no
loner undefined. Setting the $w$ bit will cause the fpage to be mapped
writable (rather than just read-only) and setting the $g$ bit causes
the fpage to be granted (rather than just mapped). The \emph{snd base}
is the mapping hot spot as described in section~\ref{sec:msgdata}.

The kernel will interpret each pair of dwords of the in-line part
(starting from the short message part and continuing to the long
message part, if present) as fpage descriptors until an invalid
descriptor is encountered. This and any further dwords are then
interpreted as by value data.

Note that all in-line data is copied to the receiver, including any
initial parts which are interpreted as fpage descriptors.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{String Dopes}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

The last component making up a long message are string dopes. There
can be zero or more string dopes, with the exact number specified in
the \emph{size dope} of the message header. Each string dope describes
a region in memory where out-of-line data can be copied from (on an
IPC send) and copied to (on an IPC receive).  The size and location of
each string is specified in a string dope. The kernel copies data from
sender memory, specified by the sender string dopes, to the receiver's
memory, specified by the receiver's string dopes. Each string dope
occupies four dwords and its format is:

\vspace{15pt}
\noindent\begin{tabular}{lcr} 
\hspace*{100pt}& \cbox{*rcv string}{64}{32} & \\
& \cbox{rcv string size}{64}{32} &\\
& \cbox{*snd string}{64}{32} & \\
& \cbox{snd string size}{64}{32} &
\end{tabular}

The first part of the string dope specifies the size and location of
the string the caller wants sent to the destination, while the second
part specifies the size and location of a buffer where the caller is
willing to receive a string. \textbf{Note} that strings do not have to
be aligned, and that their size is specified in \emph{bytes}.


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Sending/Receiving IPC Messages}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Before considering \emph{how} to send or receive it is necessary to
decide \emph{what} form of data is to be sent. In particular, a
decision must be made on whether to send data in-line or as strings.
Both have the same effect of making a copy of the sender's data
available to the receiver. The difference lies in efficiency and
appropriateness.

In-line data needs to be copied to a buffer first and must also be
aligned. Thus the in-line option is best for small amounts of data and
is useful when some marshaling is required anyway. Sending short
strings as in-line data is more efficient as it avoids setting up
string dopes and may also be done in registers.

Strings avoid extra copying and can be located anywhere in memory (no
alignment necessary) but require buffers to be specified (via string
dopes). Buffer specifications must also be consistent on both the
sender and the receiver end. In particular, the receiver must specify
and expect to receive the (at least) same number and size strings that
the sender sends.

The C interface to L4's system calls provides a number of IPC
operations. They are differentiated in the following ways:

\begin{itemize}

\item Single send or receive versus a combined send and receive.
        
\item Receive from specific sender (closed) or any sender (open).

\item Deceiving or non-deceiving IPC.

\end{itemize} 

To send or receive a message, certain parameters must be provided.

\begin{itemize}
        
\item \emph{dest/src} Identifier of message destination/source thread
  respectively.
        
\item \emph{snd\_msg/rcv\_msg} Descriptor for long part of message,
  for send/receive part of IPC respectively.

\item \emph{snd\_reg/rcv\_reg} Short part of message (artifact of C
  interface) for send/receive part of IPC respectively.

\item \emph{timeout} Timeout specification. Used to ensure that a
  thread need not be blocked indefinitely.

\item \emph{result} Variable to store the result status of the IPC
  operation.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\cbstart
\subsubsection{L4 IPC Message Summary}

In summary, an L4 IPC operation can have a send and a receive
phase.  The \emph{snd\_msg} descriptor describes what is to be sent, and the
\emph{rcv\_msg} descriptor describes what can be received. For the IPC to be
successful, the sender's send descriptor and the receiver's receive
descriptor must be compatible.

Every successful IPC transfers some by-value data, the register (or
short) part of the direct string (8 bytes on ix86, 64 bytes on
R4x00). In addition, the following may be transferred, provided the
\emph{snd\_msg} descriptor says so, and the \emph{rcv\_msg} descriptor
allows it:

\begin{itemize}

\item a bigger direct string, provided that:
\begin{itemize}
\item the send descriptor points to a  message descriptor  specifying a
     non-zero number of dwords in the \emph{send dope}, and
\item the receive descriptor points to a message descriptor specifying a
     non-zero number of dwords in the \emph{size dope}, and
\item there is no error;
\end{itemize}

\item one or more indirect strings, provided that:
\begin{itemize}
\item the send descriptor points to a  message descriptor specifying a
     non-zero number of strings in the \emph{send dope}, and
\item the receive descriptor points to a message descriptor specifying a
     non-zero number of strings in the \emph{size dope}, and
\item there is no error;
\end{itemize}

\item one or more page mappings or grants, provided that
\begin{itemize}
\item the \emph{m}-bit is set in the send descriptor, and
\item the beginning of the sender's direct string (starting with the
     register part) contains at least one valid fpage descriptor, and
\item the receive descriptor either has the form of a valid \emph{receive
     fpage} and has the \emph{m}-bit set, or points to a message
     descriptor containing a valid \emph{receive fpage}, and
\item there is no error.
\end{itemize}
\end{itemize}

Note that the structure of the message descriptor and the string dopes
make it easy to use the same message header for sending and receiving
(i.e., having the \emph{send descriptor} and \emph{receive descriptor}
point to the same address). The \emph{send dope} specifies the size of
the direct string and the number of indirect strings for the send part
(if any) of the IPC, while the \emph{size dope} specifies the size of
the buffer for the direct string and the number of buffers for indirect
strings for the receive operation (if any). Note that using the same
message descriptor for sending and receiving implies using the same
buffer for the direct string. For indirect strings, each string dope
specifies separately the location and size of the buffers for the
strings to be sent and received. If the IPC does not contain a send
\textbf{and} a receive part, then some of the information in the message
header is not used. Similarly, if the send and receive descriptors point
to different message structures, some of the information in them is unused.

Obviously, if the same message descriptor is used for sending and
receiving, receiving a direct string (longer than the register part)
will overwrite the string sent. Similarly, if the \emph{receive string}
of some string dope points to the same address as the \emph{send string}
of the same or another string dope, then receiving may overwrite some of
the data which has been sent. However, as the send part of the IPC is
guaranteed to be concluded before any receive action takes place, this
does not create any problems if the sender does not need the data any
more. The data to be sent will have been safely copied to the receiver
prior to the receive part of the IPC overwriting it on the caller's end.

\cbend

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{L4 Timeouts}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Timeouts are used to control IPC operations. Each IPC operation
specifies four timeout values. The first two are with respect to the
time \emph{before message transfer starts}. These timeouts are no
longer relevant once message transfer starts. \\ 
 
\begin{center} 
\bbox{$m_r$}{8}\bbox{$m_s$}{8}\bbox{$p_s$}{4}\bbox{$p_r$}{4}\bbox{$e_s$}{4}\bbox{$e_r$}{4} 
\end{center} 

\begin{description}

\item[receive timeout] Specifies how long to wait for an incoming
  message. The receive operation fails if the timeout period is
  exceeded before message transfer starts. The receive timeout is
  calculated as $m_r4^{15-e_r} \mu s$.

\item[send timeout] Specifies how long IPC should try to send a
  message. The send operation fails if the timeout period is exceeded
  before message transfer starts. The send timeout is calculated as
  $m_s4^{15-e_s} \mu s$.

\end{description}

The other timeout values are used if a page fault occurs during an IPC
operation. A page fault is converted to an RPC to a pager by the
kernel (see section~\ref{sec:pf}). The page fault timeouts are with
respect to this RPC.

\begin{description}

\item[receive page fault timeout] Used for both the send and receive
  timeouts of the page fault RPC when a page fault occurs in the
  sender's address space during an IPC. This value is set by the
  receiver and is calculated as $4^{15-p_r} \mu s$.

\item[send page fault timeout] Used for both the send and receive
  timeouts of the page fault RPC when a page fault occurs in the
  receiver's address space during an IPC. This value is set by the
  sender and is calculated as $4^{15-p_s} \mu s$.

\end{description}

There are two special timeout values: $\infty$ and 0. An infinite
value means no timeout (i.e.\ possibly indefinite blocking) and is
specified by zero values of $e$ or $p$. A zero timeout value
represents non-blocking IPC and is specified by zero values of $m$
(with $e > 0$). A maximum value for $p$ ($p = 15 $) means that the IPC
will fail if a page fault occurs.


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{L4 IPC Result Status}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

The status of each IPC operation is returned in a message dope with
the following format.\label{s:ccode}

\begin{center}
\cbox{0}{32}{10}\cbox{mwords}{19}{9}\bbox{strings}{5}% 
                          \bbox{$cc$}{8}\\
\end{center}

\begin{description}

\item[mwords] Size \emph{in words} of in-line data received (excluding
  register data).

\item[str] Number of strings received.

\item[cc] Condition code. \\ \\ 
  \bbox{$ec$}{4}\abox{$i$}{1}\abox{$r$}{1}\abox{$m$}{1}\abox{$d$}{1}
  \\ \\ \textbf{ec} is an \emph{error code} associated with the IPC. A
  zero value for \textbf{ec} implies a successful IPC while a non-zero
  value means the IPC failed for some reason. On IPC failure, the
  actual value of \textbf{ec} reports the reason for the failure
  (refer to reference manual). A common cause of IPC failure results
  when the receiver expects less than what is really sent (i.e.\ the
  receive buffer is too small, not providing enough receive strings,
  etc.). Note that the value of \textbf{ec} is also delivered as the
  return value of the IPC procedures in the C library interface.

  In the case of a truncated IPC the \micro-kernel provides no
  information on how much data the sender was trying to transmit.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Send/Receive Protocol}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

In the overview to this chapter, it was mentioned that the sender and
receiver of an IPC must make certain agreements. Sender and receiver
must agree on the following points for the IPC:

\begin{itemize}

\item The size of data to be copied.

\item The number and size of strings to be transferred.

\item Whether the IPC involves memory mappings (the presence of
  fpages).

\end{itemize}

The kernel does not provide the receiver with any information (e.g.
size of data) concerning the incoming message. Thus, a user message
protocol needs to be defined beforehand to ensure agreement on the
above points. In general, the receiver can expect more from the sender
than is actually sent but not less.

Example of such a protocols are:

\begin{itemize}

\item The sender marshals in-line data into a particular structure
  which the receiver will be expecting. Depending on the structure and
  context, the receiver may not make use of the entire structure but
  will receive the entire structure regardless (e.g. one field of the
  structure may identify the context and consequently how the other
  fields are to be interpreted).

\item The receiver always receives a maximum number of maximum size
  strings.

\item Use two IPCs. The first one allows the sender to establish an
  agreement with the receiver. The second IPC is the main message in
  the form established by the first IPC.

\end{itemize} 

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sending}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%


The following is a suggested procedure that can be followed to send a message.

\begin{enumerate}

\item Declare a result status variable.

\item Declare a register buffer for the short part of the message. If
  there is any in-line data copy fpages and/or by-value data into the
  buffer.

\item If a long message is required, decide on a message format and
  determine the message descriptor. The format is determined by the
  number of fpages, the amount of by-value data and the number of
  strings to be sent.

  \begin{enumerate}

  \item Fill in the message header.
                
  \item Copy in fpage descriptors (if any).
        
  \item Copy in by-value data (if any).

  \item Copy in (send) string dopes, one for each string.

  \end{enumerate} 

\item Determine the thread id of the desired receiver thread.

\item Determine the desired timeout period.

\item Provide the parameters for one of the C interface procedures
  which allows for an IPC send.

\end{enumerate}

\example{Sending a short message}

This example illustrates sending a short message. Assume the following
conditions:

\begin{itemize}

\item A single non-deceiving IPC send to a specific thread.
\item The receiver thread is $\sigma_0$.
\item Purely register based message (short message).
\item No timeout (indefinite blocking).

\end{itemize}

Then following the suggested procedure:

\begin{enumerate}

\item \emph{Declare a result status variable.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+}

\item \emph{Declare a register buffer.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t rmsg;+} \\ \\
  \hspace*{10pt} At this point, in-line data may be copied into the 
  register buffer. For example (Note that the entire buffer need not 
  be used): \\ \\
  \hspace*{20pt} {\footnotesize\verb+rmsg.reg[0] =+} \ldots; {\footnotesize\verb+ /* a dword */+} \\
  \hspace*{20pt} {\footnotesize\verb+rmsg.reg[1] =+} \ldots; {\footnotesize\verb+ /* a dword */+} \\
  \hspace*{50pt} \vdots

\item \emph{If a long message is required, decide on a message format.}
  \\ \\ \hspace*{10pt}
  Not required for a short message. To indicate that the message is 
  purely message based, use {\footnotesize\verb+L4_IPC_SHORT_MSG+} (constant defined in
  {\footnotesize\verb+ipc.h+}) for the message descriptor (\emph{snd\_msg} parameter).

\item \emph{Determine the thread id of the desired receiver thread.} \\
  \\ \hspace*{10pt}
  The thread id of $\sigma_0$ is given by {\footnotesize\verb+SIGMA0_TID+} 
  (constant defined in {\footnotesize\verb+sigma0.h+}).
  
\item \emph{Determine the desired timeout period.} \\ \\ \hspace*{10pt}
  An infinite timeout period is provided by the constant 
  {\footnotesize\verb+L4_IPC_NEVER+} (defined in {\footnotesize\verb+types.h+}). 
  
\item \emph{Provide the parameters for one of the C interface 
    procedures.} \\ \\ \hspace*{10pt}
  For the given conditions the most appropriate C interface procedure 
  is:\\ \\
  \hspace*{20pt} {\footnotesize\verb+int l4_mips_ipc_send(l4_thread_t dest,+} \\ 
  \hspace*{130pt} {\footnotesize\verb+const void *snd_msg,+} \\
  \hspace*{130pt} {\footnotesize\verb+l4_ipc_reg_msg_t *snd_reg,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_timeout_t timeout,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_msgdope_t *result)+}\\ \\
  \hspace*{10pt} Filling in the parameters using information from steps
  1-5 gives the desired system call: \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_send(SIGMA0_TID, L4_IPC_SHORT_MSG,+}\\
  \hspace*{140pt} {\footnotesize\verb+&rmsg, L4_IPC_NEVER, &result);+}

\end{enumerate}  

\example{Sending a long message} 

This example illustrates sending a long message that contains in-line
as well as string data. Assume the following conditions:

\begin{itemize}

\item A single non-deceiving IPC send to a specific thread.
\item The receiver thread is $\sigma_0$.
\item Uses in memory message buffer (long message).
\item No fpages.
\item The in-line by-value data to be sent is stored in a variable
  with the following declaration: \\
  \hspace*{20pt} {\footnotesize\verb+dword_t buf[10];+}
\item One string is to be sent. The string is a null terminated
  character string called {\footnotesize\verb+sbuf+}.
\item No timeout (indefinite blocking).
  
\end{itemize}

Again, following the suggested procedure:

\begin{enumerate}

\item \emph{Declare a result status variable.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+}
  
\item \emph{Declare a register buffer and copy data into it.} \\ \\
  \hspace*{10pt} Note that in this case, no direct copying is needed. All
  that is required is to provide the address of the existing buffer -
  the C interface stub will load the registers from this buffer. That is, the
  \emph{snd\_reg} parameter will be: \\ \\
  \hspace*{20pt} {\footnotesize\verb+(l4_ipc_reg_msg_t*) buf +} 
  
\item \emph{If a long message is required, decide on a message format.}
  \\ \\ \hspace*{10pt}
  For this example, the message format will need to include a header,
  a two dword in-line buffer (want to send a 10 dword buffer with first
  8 dwords in registers) and one string dope. Thus, can declare the 
  message as: \\ \\
  \hspace*{20pt} {\footnotesize\verb+typedef struct msg {+} \\
    \hspace*{60pt} {\footnotesize\verb+l4_msghdr_t msghdr;+} \\
    \hspace*{60pt} {\footnotesize\verb+dword_t buf[2];+} \\
    \hspace*{60pt} {\footnotesize\verb+l4_strdope_t strdope;+}\\
    \hspace*{20pt} {\footnotesize\verb+} msg_t;+} \\ \\
  \hspace*{20pt} {\footnotesize\verb+msg_t lmsg;+}

  \hspace*{10pt} The message descriptor is given by: \\ \\
  \hspace*{20pt} {\footnotesize\verb+(msg_t *) (&lmsg & ~(L4_IPC_SHORT_FPAGE | L4_IPC_DECEIT))+} \\ \\
  \hspace*{10pt} The message descriptor is just the address of 
  the message buffer with the last two bits masked out (ie. $m$ =
  0 and $d$ = 0) to indicate a non-deceiving send 
  operation with no mappings.     

  \begin{enumerate}
    
  \item \emph{Fill in the message header.} \\
    
    \hspace*{10pt} The important point to note is that we need
    to send two dwords and one string and and that no fpages are 
    being received. Note also that the \emph{send dope} and the
    \emph{size dope} will be the same since there is no receive 
    involved.\\ \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.snd_dope.msgdope = 0; /* zero out all fields */+} \\ 
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.snd_dope.md.dwords = 2; /* number of dwords to send */+} \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.snd_dope.md.strings = 1; /* number of strings to send */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.size_dope.msgdope = lmsg.msghdr.snd_dope.msgdope; /* send & size dopes */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.rcv_fpage.fpage = 0; /* not receiving any fpages */+} \\ \\
    \hspace*{10pt} Note that the the first and last expressions are
    not strictly necessary as the kernel only looks at the
    fields that are actually used.  
    
  \item \emph{Copy in fpage descriptors (if any).} \\ \\
    \hspace*{10pt} No fpages in this example.
    
  \item \emph{Copy in by-value data (if any).} \\ \\
    \hspace*{10pt} No in-memory fpages but have two dwords of 
    by-value data. \\ \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.buf[0] = buf[8];+} \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.buf[1] = buf[9];+} 
    
  \item \emph{Copy in (send) string dopes, one for each string.} \\ \\
    \hspace*{10pt} One string dope describing one send string and 
    no receive string. \\ \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.snd_size = strlen(sbuf); /* size of string in bytes */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.snd_str = sbuf; /* start of string */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.rcv_size = 0; /* no receive string */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.rcv_str = 0;+} 
  \end{enumerate} 
  
\item \emph{Determine the thread id of the desired receiver thread.} \\
  \\ \hspace*{10pt}
  The thread id of $\sigma_0$ is given by {\footnotesize\verb+SIGMA0_TID+} 
  (constant defined in {\footnotesize\verb+sigma0.h+}). 
  
\item \emph{Determine the desired timeout period.} \\ \\ \hspace*{10pt}
  An infinite timeout period is provided by the constant 
  {\footnotesize\verb+L4_IPC_NEVER+} (defined in {\footnotesize\verb+types.h+}). 
  
\item \emph{Provide the parameters for one of the C interface 
    procedures.} \\ \\ \hspace*{10pt}
  Once again, the most appropriate C interface procedure is:\\ \\
  \hspace*{20pt} {\footnotesize\verb+int l4_mips_ipc_send(l4_thread_t dest,+} \\ 
  \hspace*{130pt} {\footnotesize\verb+const void *snd_msg,+} \\
  \hspace*{130pt} {\footnotesize\verb+l4_ipc_reg_msg_t *snd_reg,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_timeout_t timeout,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_msgdope_t *result)+}\\ \\
  \hspace*{10pt} Filling in the parameters using information from steps
  1-5 gives the desired system call: \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_send(SIGMA0_TID,+}\\
  \hspace*{80pt} {\footnotesize\verb+(msg_t *) (((dowrd_t)&lmsg) & ~(L4_IPC_SHORT_FPAGE | L4_IPC_DECEIT)),+}\\
  \hspace*{80pt} {\footnotesize\verb+(l4_ipc_reg_msg_t*) buf, L4_IPC_NEVER, &result);+}
  
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Receiving}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%


The following is a suggested procedure that can be followed to receive
a message.

\begin{enumerate}

\item Declare a result status variable.

\item Declare a register buffer for the short part of the message.

\item If a long message is required, decide on a message format and
  determine the message descriptor. The format is determined by the
  number of fpages, the amount of by-value data and the number of
  strings to be received.
        
  \begin{enumerate}

  \item Fill in the message header.
  \item Copy in (receive) string dopes, one for each string.

  \end{enumerate}

\item For a closed receive, determine the thread id of the desired
  sender thread. For an open receive, declare a variable to store the
  thread id of the sender.
  
\item Determine the desired timeout period.

\item Provide the parameters for one of the C interface procedures
  which allows an IPC receive.

\end{enumerate}

\example{Receiving a short message}

This example illustrates receiving a short message. Assume the
following conditions:

\begin{itemize}

\item A single non-deceiving IPC receive from any thread.
\item Purely register based message (short message).
\item No timeout (indefinite blocking).

\end{itemize}

Then following the suggested procedure:

\begin{enumerate}

\item \emph{Declare a result status variable.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+}

\item \emph{Declare a register buffer.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t rmsg;+} \\ 

\item \emph{If a long message is required, decide on a message format.}
  \\ \\ \hspace*{10pt}
  Not required for a short message. To indicate that the message is 
  purely message based, use {\footnotesize\verb+L4_IPC_SHORT_MSG+} (constant defined in
  {\footnotesize\verb+ipc.h+}) for the message descriptor (\emph{rcv\_msg} parameter).

\item \emph{ For an open receive, declare a variable to store the thread id of the sender.} \\
  \\ \hspace*{20pt} {\footnotesize\verb+l4_threadid_t thrdid;+}
  
\item \emph{Determine the desired timeout period.} \\ \\ \hspace*{10pt}
  An infinite timeout period is provided by the constant 
  {\footnotesize\verb+L4_IPC_NEVER+} (defined in {\footnotesize\verb+types.h+}). 
  
\item \emph{Provide the parameters for one of the C interface 
    procedures.} \\ \\ \hspace*{10pt}
  For the given conditions the most appropriate C interface procedure 
  is:\\ \\
  \hspace*{20pt} {\footnotesize\verb+int l4_mips_ipc_wait(l4_thread_t *src,+} \\ 
  \hspace*{130pt} {\footnotesize\verb+const void *rcv_msg,+} \\
  \hspace*{130pt} {\footnotesize\verb+l4_ipc_reg_msg_t *rcv_reg,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_timeout_t timeout,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_msgdope_t *result)+}\\ \\
  \hspace*{10pt} Filling in the parameters using information from steps
  1-5 gives the desired system call: \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_wait(&thrdid, L4_IPC_SHORT_MSG,+}\\
  \hspace*{140pt} {\footnotesize\verb+&rmsg, L4_IPC_NEVER, &result);+}
  
\end{enumerate}  

\example{Receiving a long message}

This example illustrates receiving a long message that contains
in-line as well as string data. Assume the following conditions:

\begin{itemize}

\item A single non-deceiving IPC receive from a specific thread. Assume the sender id has been 
  stored in a variable with the declaration: \\ \\
  \hspace*{10pt} {\footnotesize\verb+ l4_threadid_t senderid;+}
\item Uses in memory message buffer (long message).
\item No fpages.
\item 10 dwords of in-line by-value data is to be received.
\item One string is to be received and stored in a character string buffer with the declaration: \\ \\
  \hspace*{10pt} {\footnotesize\verb+char sbuf[MAX_BUF];+}.\\
  \hspace*{15pt} where {\footnotesize\verb+MAX_BUF+} is a constant.
\item No timeout (indefinite blocking).
  
\end{itemize}

The above assumptions made by the receiver actually defines the
send/receive protocol. In particular, the receiver expects \emph{at
  most} 10 dwords of in-line data and one string of maximum size
{\footnotesize\verb+MAX_BUF+}. Note that the sender may actually send less than the
expected maximum (but not more). That is, there may be less than 10
dwords of in-line data, no string data or a string smaller than the
maximum size.

Then following the suggested procedure:

\begin{enumerate}

\item \emph{Declare a result status variable.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+}
  
\item \emph{Declare a register buffer.} \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t rmsg;+} \\ 
  
\item \emph{If a long message is required, decide on a message format.}
  \\ \\ \hspace*{10pt}
  For this example, the message format will need to include a header,
  a two dword in-line buffer (want to receive a 10 dwords with first
  8 dwords in registers) and one string dope. Thus, can declare the 
  message as: \\ \\
  \hspace*{20pt} {\footnotesize\verb+typedef struct msg {+} \\
    \hspace*{60pt} {\footnotesize\verb+l4_msghdr_t msghdr;+} \\
    \hspace*{60pt} {\footnotesize\verb+dword_t buf[2];+} \\
    \hspace*{60pt} {\footnotesize\verb+l4_strdope_t strdope;+}\\
    \hspace*{20pt} {\footnotesize\verb+} msg_t;+} \\ \\
  \hspace*{20pt} {\footnotesize\verb+msg_t lmsg;+}
  
  \hspace*{10pt} The message descriptor is given by: \\ \\
  \hspace*{20pt} {\footnotesize\verb+(msg_t *) (((dword_t)&lmsg) & ~(L4_IPC_SHORT_FPAGE | L4_IPC_DECEIT))+} \\ \\
  \hspace*{10pt} The message descriptor is just the address of 
  the message buffer with the last two bits masked out (ie. $m$ =
  0 and $d$ = 0) to indicate a non-deceiving receive 
  operation with no mappings.
  
  \begin{enumerate}
    
  \item \emph{Fill in the message header.} \\
    
    \hspace*{10pt} The important point to note is that we need
    to send two dwords and one string and and that no fpages are 
    being received. Note also that the \emph{size dope} will be greater
    than the \emph{send dope} since there is no send 
    involved.\\ \\ 
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.size_dope.md.dwords = 2; /* number of dwords */+} \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.size_dope.md.strings = 1; /* number of strings */;+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.msghdr.snd_dope = 0; /* no send (actually not needed)*/+}\\
    
  \item \emph{Copy in (receive) string dopes, one for each string.} \\ \\
    \hspace*{10pt} One string dope describing one receive string and 
    no send string. \\ \\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.rcv_size = MAX_BUF; /* max bytes receive string */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.rcv_str = sbuf; /* start of string */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.snd_size = 0; /* no send string */+}\\
    \hspace*{20pt} {\footnotesize\verb+lmsg.strdope.snd_str = 0;+} 
    
  \end{enumerate}
  
\item \emph{ For a closed receive, determine the thread id of the desired sender thread. } \\ \\
  \hspace*{10pt} The sender id is stored in the variable {\footnotesize\verb+senderid+}
  
\item \emph{Determine the desired timeout period.} \\ \\ \hspace*{10pt}
  An infinite timeout period is provided by the constant 
  {\footnotesize\verb+L4_IPC_NEVER+} (defined in {\footnotesize\verb+types.h+}). 
  
\item \emph{Provide the parameters for one of the C interface 
    procedures.} \\ \\ \hspace*{10pt}
  For the given conditions the most appropriate C interface procedure 
  is:\\ \\
  \hspace*{20pt} {\footnotesize\verb+int l4_mips_ipc_receive(l4_thread_t src,+} \\ 
  \hspace*{130pt} {\footnotesize\verb+const void *rcv_msg,+} \\
  \hspace*{130pt} {\footnotesize\verb+l4_ipc_reg_msg_t *rcv_reg,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_timeout_t timeout,+}\\ 
  \hspace*{130pt} {\footnotesize\verb+l4_msgdope_t *result)+}\\ \\
  \hspace*{10pt} Filling in the parameters using information from steps
  1-5 gives the desired system call: \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_receive(senderid,+}\\
  \hspace*{80pt} {\footnotesize\verb+(msg_t *) ((dword_t)&lmsg) & ~(L4_IPC_SHORT_FPAGE | L4_IPC_DECEIT))+}\\
  \hspace*{80pt} {\footnotesize\verb+&rmsg, L4_IPC_NEVER, &result);+}
  
\end{enumerate}

Note that the kernel does not tell you how much data was actually
transmitted, this information must either be explicitly encoded in the
message or must be implicit in the protocol used between sender and
receiver.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Clans and Chiefs}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Concepts}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

As described in Section~\ref{s:i:c&c}, the clans and chiefs concept is
one of the \emph{security mechanisms} used by L4 to allow
\emph{protection policies} to be implemented for its IPC message
transfers.

Clans are created via a hierarchy of tasks. A task that creates
another task becomes the chief of that task and the set of tasks
created by the chief forms the chief's clan. Note that there is an
implementation limit on the depth of the task hierarchy\footnote{16 on
  R4k.}.

Security is provided through a number of restrictions and enforced
protocols:

\begin{itemize}

\item A task can only (directly) kill another task if that task is in
  its own clan or (indirectly) by killing its chief.

\item Intra-clan messages (those that don't cross clan boundaries) are
  delivered directly from sender to receiver.

\item Inter-clan messages (those that cross clan boundaries), whether
  incoming or outgoing, are routed from the sender to the sender's
  chief instead of going to the specified receiver (in the other
  clan). The chief has access to all parts of the message and can
  inspect and modify the message before forwarding it or even suppress
  the message entirely. If forwarding the message, the chief can make
  use of deceiving IPC so that the message will seemingly come from
  the original sender.

\item Deceiving is \emph{direction-preserving}: L4 will only allow the
  deceit if, on an outgoing message, the virtual sender ID belongs
  (directly or indirectly) to the sender's clan, or, on a message
  going inside the clan the virtual sender is external to the sender's
  clan. Furthermore, the receiver is alerted to the deceit (via the
  \(d\)-bit in the condition code returned from the call, see
  Section~\ref{s:ccode}).


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Usage and Cost}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Some usage examples of clans and chiefs are:

\begin{description}

\item[network proxies] Have a master clan for each node which receives
  all inter-node IPC and forwards it.

\item[system upgrade] Have a clan for each \emph{system version}. The
  chief for each clan can then translate message formats between old
  and new versions as well as any other necessary adjustments.

\item[user-based access permissions] All tasks for a user are
  encapsulated in a single clan. The chief of each clan (user) can
  implement arbitrary access protocols.

\item[confinement] Encapsulating a task in its own clan may be used to
  prevent it from leaking data or mounting denial-of-service attacks.

\end{description}

The cost of \emph{supporting} clans and chiefs is about four cycles
per IPC.  The cost of \emph{using} clans and chiefs is the product of
the number of IPC operations and the number of chiefs involved. This
last point implies that the task hierarchy should be kept as flat as
possible in the interests of efficiency. \\ 

\example{Clans and chiefs}

This example illustrates one possible inter-clan IPC scenario. It also
demonstrates the use of deceiving IPC. Figure~\ref{fig:clanex} shows
the setup for this example. Task $T_2$ is the chief of task $T_1$
while task $T_3$ is the chief of task $T_4$. $T_1$ wants to send an
inter-clan message to $T_4$. The dashed line shows the virtual path of
the message from $T_1$ to $T_4$ but the actual path is shown by the
normal line. $T_1$ sends to $T_4$ but the message is intercepted by
its chief, $T_2$. $T_2$ tries to pass the message to $T_4$ but the
message is actually intercepted by $T_3$ which finally forwards the
message to $T_4$. Deceiving IPC is used when $T_2$ and $T_3$ forwards
their messages. The effect of this is that $T_4$ will see the message
it eventually receives as coming directly from $T_1$. \\ 

\begin{figure}[htb]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/clanex.eps}
\end{center}
\caption{Clans and Chiefs Example}
\label{fig:clanex}
\end{figure}

There are a few things to note before proceeding with this example.

\begin{itemize}

\item The use of deceiving IPC as in this example is \emph{not} a
  mandatory part of using the clans and chiefs mechanism. Depending on
  the situation, the user may decide that $T_4$ does not need to know
  that the message was originally from $T_1$ or the identity of the
  original sender may be encoded as part of the message. In either
  case, deceiving IPC need not be used.

  However, deceiving is necessary to maintain proper RPC semantics in
  the case of redirection: If \(T_1\) attempts an RPC-like
  communication with \(T_4\) (using {\footnotesize\verb+l4_mips_ipc_call+}), the
  reply must come from \(T_4\) for \(T_1\) being able to receive it.
  See also Section~\ref{s:u:osstruct} for an example.

\item In terms of sending an inter-clan message and the actual path
  shown in figure~\ref{fig:clanex}, the only communication which must
  take place is from $T_1$ to $T_2$ (i.e.\ from the original sender to
  its chief). The path from $T_2$ to $T_3$ and from $T_3$ to $T_4$ may
  never occur because these chiefs may decide to suppress the message.

\item The thread \(T_2\) actually receiving the intercepted IPC is
  lthread~0 of the chief task.

\end{itemize}

Code fragments for each of the tasks may look as follows.

\begin{description}

\item[$T_1$ code:]  
  $T_1$ does not need to do anything special. It just attempts to
  send directly to $T_4$. So the code is: \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_msgdope_t result;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_threadid_t t4id;+} \\ \\
  \hspace*{10pt} {\footnotesize\verb+t4id = +} \dots {\footnotesize\verb+ /* assign t2's thread id */+}\\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_ipc_send(t4id, L4_IPC_SHORT_MSG, &msg, L4_IPC_NEVER, &result);+} \\
  \hspace*{40pt} \vdots   
  
\item[$T_2$ code:]
  $T_2$ waits to receive (actually intercept) a message from a client 
  ($T_1$ in this case)
  and passes it on to $T_4$ (after possibly inspecting and modifying 
  the message) using a deceiving send with $T_1$ as the virtual sender. 
  So the code is: \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_msgdope_t result;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_threadid_t clientid, t4id;+} \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_ipc_wait(&clientid, L4_IPC_SHORT_MSG, &msg, L4_IPC_NEVER, &result);+} \\ \\
  \hspace*{10pt} {\footnotesize\verb+/* Inspect/modify message before forwarding */+}\\ \\
  \hspace*{10pt} {\footnotesize\verb+t4id = +} \dots {\footnotesize\verb+ /* assign t4's thread id */+}\\ \\
  \hspace*{15pt} {\footnotesize\verb+/* Send deceiving IPC to T4 with client as virtual sender */+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_ipc_send_deceiving(t4id, clientid, L4_IPC_SHORT_MSG, &msg,+} \\
  \hspace*{10pt} {\footnotesize\verb+                           L4_IPC_NEVER, &result);+} \\ 
  \hspace*{40pt} \vdots   
  
\item[$T_3$ code:]
  $T_3$ intercepts the message from $T_2$ and directly forwards its 
  message to $T_4$. Note that $T_3$ believes it receives its message 
  directly from $T_1$ because of the deceiving IPC used by $T_2$.
  The code for $T_3$ is similar to that for $T_2$ and is not repeated.
  
\item[$T_4$ code:]
  $T_4$ does not need to know of the actual path taken by the message.
  It simply receives the message and thinks (ignoring the
  \(d\)-bit in the returned condition code) that it has come directly
  from $T_1$. So the code is: \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_msgdope_t result;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_threadid_t senderid;+} \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_ipc_wait(&senderid, L4_IPC_SHORT_MSG, &msg, L4_IPC_NEVER, &result);+} \\
  \hspace*{40pt} \vdots   
  
\end{description}

This code assumes that $T_2$ and $T_3$ know the destination of the IPC
(it could be explicitly encoded in the message or implicitly in the
protocol). Practically this approach is most useful in such cases as a
server's using a dedicated receiver thread which forwards requests to a
number of worker threads which then reply directly back to the client
(using deceiving IPC).

A more appropriate way for a chief dealing with redirected IPC goes as
follows:

\begin{description}
\item[$T_2$ code:] ~\\
  \hspace*{10pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_msgdope_t result;+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_threadid_t clientid, destid;+} \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_ipc_chief_wait(&clientid, &destid, L4_IPC_SHORT_MSG, &msg,+} \\
  \hspace*{10pt} {\footnotesize\verb+                       L4_IPC_NEVER, &result);+} \\ \\
  \hspace*{10pt} {\footnotesize\verb+/* Inspect/modify message before forwarding */+}\\ \\
  \hspace*{15pt} {\footnotesize\verb+/* Send deceiving IPC to intended destination with client as virtual sender */+} \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_ipc_send_deceiving(destid, clientid, L4_IPC_SHORT_MSG, &msg,+} \\
  \hspace*{10pt} {\footnotesize\verb+                           L4_IPC_NEVER, &result);+} \\ 
  \hspace*{40pt} \vdots   
  
\end{description}



% 
%%% Local Variables: %%%
%%% mode: latex %%%
%%% End: %%%
