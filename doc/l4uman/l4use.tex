% Permission to make digital/hard copy of part or all of this work for
% personal or classroom use is granted without fee provided that copies
% are not made or distributed for profit or commercial advantage, the
% copyright notice, the title of the publication and its date appear, and
% notice is given that copying is by permission of the authors. To copy
% otherwise, to republish, to post on servers, or to redistribute to lists
% requires prior specific permission and/or a fee.
%
% Copyright (C) 1998 by Gernot Heiser, The University of New South Wales.


% L4 user manual: How L4 is used
% Author: Alan Au
% Created On: 20 December 1997
% Last Modified: 1 June 1998

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{\label{c:use}Using L4}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bootstrap}
\label{sec:bootstrap}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

At boot time, the kernel image is loaded into resident memory (RAM).
The first process started (in kernel mode) by the L4 bootstrap is
$\sigma_0$ (see Section~\ref{sec:sigma0}). $\sigma_0$ then in turn
starts up all the \emph{initial servers} in user mode. All initial
servers have $\sigma_0$ registered as their pager and exception
handler (i.e.$\sigma_0$ is their chief). $\sigma0$ does not allocate
any stack space for the initial servers. The initial servers must
allocate their own stack space and point the variable \emph{\_sp} to
the beginning of that allocated space.

Kernel images are built by a bootstrap linker called DIT (see
Section~\ref{sec:dit}). In building the image, the DIT identifies the
initial servers by marking them as such in the boot image. The boot
image layout is then:

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .8\textwidth
\epsfbox{eps/l4-dit.eps}
\end{center}
\caption{L4/MIPS Boot Image}
\label{fig:boot}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Resource Allocation}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:ralloc}

L4 manages several resources which it allocates on a
first-come-first-served basis. This means that the first task to
request for a particular resource will be granted it while all
subsequent requests for the same resource will fail. These resources
can only be requested by initial servers (i.e.\ by tasks which are
direct members of \(\sigma_0\)'s clan).

Specifically, the resources with this allocation policy are:

\begin{description}

\item[physical frames] All physical frames are mapped idempotently
  (i.e.\ virtual address = physical address) by $\sigma_0$. Except for
  some special kernel reserved memory, $\sigma_0$ only gives each
  frame once to the first task asking for it (see
  Section~\ref{sec:sigma0}).

\item[device addresses] Device access is memory mapped. Like physical
  memory, Pages containing device addresses are mapped once to the
  first requester.

\item[interrupts] Each interrupt can have at most one interrupt
  handler. A thread installs itself as this handler by following a set
  protocol (see Section~\ref{sec:interrupts}). The first thread to do
  so for a particular interrupt becomes the handler while all
  subsequent attempts by other threads will fail.

\item[tasks] Upon system initialisation, the full set of tasks (2048
  on R4k) is created but in an \emph{inactive} state. Tasks are
  acquired using L4's {\footnotesize\verb+task_new+} system call. Once all available
  tasks have been given out, no more tasks can be asked for (see
  Section~\ref{sec:tasks}).

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{$\sigma_0$ - The Root Pager}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:sigma0}

An \emph{initial address space}, called $\sigma_0$ automatically
exists after the system is booted. $\sigma_0$ maps physical memory
(except for some kernel reserved regions) and is idempotent (all
virtual addresses are the same as the corresponding physical address).
$\sigma_0$ also acts as its own pager\footnote{Note that this is
  somewhat MIPS specific.} by mapping any frame (writable) to the
first task requesting it. Any further requests to $\sigma_0$ for an
already mapped frame is ignored (a null reply is sent).

Figure~\ref{fig:sigma0} illustrates $\sigma_0$ and how it is commonly
used. The inclusion of \(\sigma_0\) in the kernel is specific to
L4/MIPS, \(\sigma_0\) is at user level in other implementations.

One of the first tasks that any \emph{OS personality} needs to perform
is to request all available frames from $\sigma_0$ so that $\sigma_0$
has spent all its memory. This enables the OS to have full control of
memory (other than what is reserved by L4). The OS can then provide
its own pager which maps memory to user tasks (with the appropriate
checks) in response to user page faults.

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/l4-as.eps}
\end{center}
\caption{$\sigma_0$}
\label{fig:sigma0}
\end{figure}

Part of the kernel reserved space contains the \emph{kernel
  information page} and the \emph{DIT header page}. These special
pages are mapped read-only upon request. Such mappings are part of the
$\sigma_0$ RPC protocol (see Section~\ref{sec:sigma0rpc}).


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Kernel Information Page}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

The kernel information page contains information useful for the
initial servers to find out about the environment they were started
in. Its layout is as follows:

\vspace{1ex}
\begin{center}\begin{tabular}{ll}
\cbox{kernel data}{64}{32} & +40 \\
\cbox{dit header}{64}{32} & +32 \\
\cbox{kernel}{64}{32} & +24 \\
\cbox{memory size}{64}{32} & +16 \\
\cbox{clock}{64}{32} & +8 \\
\cbox{build}{16}{8}\cbox{version}{16}{8}\cbox{``L4uK''}{32}{16} & +0\\
\end{tabular}\end{center}

\vspace{1ex}
\begin{param}{version}
              & L4/R4600 version number.\\
\end{param}
\begin{param}{build}
              & L4/R4600 build number of above version\\
\end{param}
\begin{param}{clock}
              & Number of millisecond ticks since L4 booted.\\
\end{param}
\begin{param}{memory size}
  & The amount, in bytes, of RAM installed on machine L4 is running on.\\
\end{param}
\begin{param}{kernel}
  & The address + 1 of last byte reserved by the kernel of low physical
  memory.\\
\end{param}
\begin{param}{dit header}
  & The address of the DIT header which maps out what was loaded with
  the kernel image.\\
\end{param}
\begin{param}{kernel data}
  & The address of the start of kernel reserved memory in the upper
  physical memory region.
\end{param}


The initial free physical memory available to applications lies
between kernel and kernel data. Figure~\ref{fig:kinfo} shows how the
memory is arranged. Note that the kernel information page and the DIT
header page are within the L4 reserved area while the initial servers
and other data are loaded into the free memory area.

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/kinfo.eps}
\end{center}
\caption{Physical Memory Arrangement}
\label{fig:kinfo}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{DIT}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:dit}

DIT is a MIPS specific tool used to build kernel boot images. Like the
L4 kernel itself, it has an information page describing the layout of
various programs and data that were part of the kernel image. It
consists of two parts, the initial header followed by zero of more
file headers as specified by the initial header. The initial headers
format follows below.

\vspace{2ex}
\begin{center}\begin{tabular}{ll}
\cbox{vaddr end}{32}{32} & +20 \\
\cbox{file end}{32}{32} & +16 \\
\cbox{phdr num}{32}{32} & +12 \\
\cbox{phdr size}{32}{32} & +8 \\
\cbox{phdr off}{32}{32} & +4 \\
\cbox{``dhdr''}{32}{32} & +0\\
\end{tabular}\end{center}

\begin{param}{phdr off}
  & The offset from the beginning of this header to where the file
  headers start.\\
\end{param}
\begin{param}{phdr size}
              & The size of each of the  file  headers.\\
\end{param}
\begin{param}{phdr num}
              & The number of file  headers that follow.\\
\end{param}
\begin{param}{file end}
  & The offset to the end of the kernel image file. For DIT internal use
  only.\\
\end{param}
\begin{param}{vaddr end}
  & The end of currently used physical memory space. This includes the
  L4 kernel and all other programs and data in the downloaded kernel
  image.\\
\end{param}

\noindent Each of the program headers is laid out as follows.

\vspace{2ex}
\begin{center}\begin{tabular}{ll}
\cbox{flags}{32}{32} & +28 \\
\cbox{entry}{32}{32} & +24 \\
\cbox{size}{32}{32} & +20 \\
\cbox{base}{32}{32} & +16\\
\cbox{name string}{32}{32} & +12 \\
\cbox{name string}{32}{32} & +8 \\
\cbox{name string}{32}{32} & +4 \\
\cbox{name string}{32}{32} & +0 \\
\end{tabular}\end{center}

\begin{param}{name string}
  & Null terminated string containing name of program or data
  file (truncated to 16 characters).\\
\end{param}
\begin{param}{base}
  & The base address of the program or data file.\\
\end{param}
\begin{param}{size}
  & The size of the program or data.\\
\end{param}
\begin{param}{entry}
              & The start address of the program if its executable, zero
              otherwise.\\
\end{param}
\begin{param}{flags}
              & Miscellaneous flags defined below.\\
\end{param}


\vspace{2ex}
\begin{center}\begin{tabular}{l}
\cbox{\undef}{31}{31}\abox{r}{1}\\
\end{tabular}\end{center}

\begin{param}{r}
  & If set the kernel runs this program as part of the initial servers
  upon startup. If not set, the program or data has simply been loaded
  into memory and has not been invoked.\\
\end{param}

Figure~\ref{fig:dit} shows a more detailed view of the boot image as described by the DIT header. Note that the \emph{files} Section is made up of initial servers followed by other data (possibly code or text).

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/dit.eps}
\end{center}
\caption{Detailed Boot Image}
\label{fig:dit}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{$\sigma_0$ RPC Protocol}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:sigma0rpc}

A task can request a mapping from $\sigma_0$ by sending a short
message (see Section~\ref{sec:messages}) to $\sigma_0$. The specific
request is determined by up to the first two words in the register
data of the request. If the request is valid, $\sigma_0$ sends a
mapping to the requester. Note that only tasks in $\sigma_0$'s clan
(i.e.\ the initial servers) can IPC directly to $\sigma_0$ due to the
clans and chiefs mechanisms.

$\sigma_0$ provides four mapping categories:

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Free Physical Memory}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Physical frames can be requested from $\sigma_0$ by sending the
address of the frame as the first register word in a short IPC message
to $\sigma_0$. This is a special form of a page-fault RPC (see
Section~\ref{s:pf}).

\begin{tabular}{ll}
\emph{msg.w0} (\reg{s0}) & \cbox{address}{64}{32}\\
\emph{msg.w1} (\reg{s1}) & \cbox{\undef}{64}{32}\\
\end{tabular}
\vspace{1ex}

If the requested memory is in the available range and not previously
mapped, $\sigma_0$ will send back a writable mapping for that frame to
the requester, otherwise it will send a null reply. \\ 

\example{Requesting physical memory from $\sigma_0$}

This example covers both sending a request to $\sigma_0$ for a
physical frame and successfully receiving the mapping from $\sigma_0$.
The following procedure illustrates explicit memory requests from
$\sigma_0$ but note that the same can be achieved by just touching an
unmapped page (i.e.\ read from or write to the page). The advantage of
just touching a page is decreased complexity but the cost is that
error recovery is not possible: An attempt to obtain a page already
claimed by another initial server would livelock the faulting thread.

\begin{enumerate}

\item Declare a register buffer. \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+}

\item Declare a variable to hold the address of the desired physical
  frame to be mapped. Assign that address to the variable. \\ \\
  \hspace*{10pt} {\footnotesize\verb+dword_t addr;+} \\
  \hspace*{10pt} {\footnotesize\verb+addr = +} \ldots {\footnotesize\verb+; /* some address */+}
  
\item Copy the frame address to the first word of the register buffer.
  \\ \\  \hspace*{10pt} {\footnotesize\verb+msg.reg[0] = addr;+} \\
  
\item Send the IPC request (in a short message) to $\sigma_0$. \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_send(SIGMA0_TID, L4_IPC_SHORT_MSG, &msg, L4_IPC_NEVER, &result);+} \\ \\
  {\footnotesize\verb+result+} is the usual result buffer ({\footnotesize\verb+l4_msgdope_t result;+}).
  
\item Assuming all the steps are correct so far, can now wait to
  receive the mapping from $\sigma_0$. \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_mips_receive(SIGMA0_TID,+}\\
  \hspace*{90pt} {\footnotesize\verb+(void *) ((dword_t) L4_IPC_SHORT_FPAGE |+}\\
  \hspace*{95pt} {\footnotesize\verb+(L4_WHOLE_ADDRESS_SPACE << 2)),+}\\
  \hspace*{90pt} {\footnotesize\verb+&msg, L4_IPC_NEVER, &result);+} \\ \\
  Note that the message reply from $\sigma_0$ is expected to include
  a single page mapping. Recall from the message descriptor discussion
  in Section~\ref{sec:messages} that mappings can be received as part of
  a short message by providing a receive fpage for the message
  descriptor parameter (\emph{rcv\_msg}) instead of the start address
  (or nil) of a message buffer.
  
  The $m$-bit needs to be set to indicate that fpages are to be received.
  This is done via a bit wise \emph{OR} with {\footnotesize\verb+L4_IPC_SHORT_FPAGE+}
  (defined in {\footnotesize\verb+ipc.h+}).
  
  In this example, the mappings are made idempotent by specifying the
  whole address space as the receive fpage. Again, recall that the
  fpage format for this is: \\
  
  \begin{tabular}{ll}
    \hspace*{80pt}&\\[\Up]
                                %
fpage$(0,2^{64} - K)$ &
\cbox{0}{52}{20}\bbox{0}{3}\cbox{64}{7}{7}\abox{\undef{}}{1}\abox{\undef{}}{1}\\[20pt]
%
\end{tabular}

        {\footnotesize\verb+L4_WHOLE_ADDRESS_SPACE+} is defined to be {\footnotesize\verb+64+} (in
        {\footnotesize\verb+types.h+}) and with some thought, it can be seen that
        {\footnotesize\verb+L4_WHOLE_ADDRESS_SPACE << 2+} corresponds exactly to the above
        fpage format. (See the next example for a macro that helps perform
        this task.)
        
\end{enumerate}

For added elegance, it is worth noting that the last two steps above
can be combined by using the appropriate C procedure. An IPC send to a
particular thread followed immediately by a closed receive from the
same thread (usual RPC semantics) is facilitated by the
{\footnotesize\verb+l4_mips_ipc_call+} system call. The last two steps above can then
be replaced by a single step: \\ 

\hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_call(SIGMA0_TID, L4_IPC_SHORT_MSG, &msg,+}\\
\hspace*{110pt} {\footnotesize\verb+(void *) ((dword_t) L4_IPC_SHORT_FPAGE |+}\\
\hspace*{160pt} {\footnotesize\verb+(L4_WHOLE_ADDRESS_SPACE << 2)),+}\\
\hspace*{110pt} {\footnotesize\verb+&msg, L4_IPC_NEVER, &result);+}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Kernel Information Page}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Unlike free physical frames, the kernel information allows for
multiple mappings to multiple requesters. A request for the kernel
information page can be made by providing a particular invalid address
(-3 on MIPS) as the first register word in a short IPC to $\sigma_0$.
\\ 

\begin{tabular}{ll}
\emph{msg.w0} (\reg{s0}) & \cbox{0xFFFFFFFFFFFFFFFD}{64}{32}\\
\emph{msg.w1} (\reg{s1}) & \cbox{\undef}{64}{32}\\
\end{tabular}
\vspace{1ex}

$\sigma_0$ will respond to a request in the above format by mapping
the kernel information page read-only to the requester. The requester
receives the address of the kernel information page in \textbf{s0}
assuming a one to one mapping.\\ 

\example{Requesting the Kernel Information Page from $\sigma_0$}

This example covers both sending a request to $\sigma_0$ for the
kernel information page and successfully receiving the mapping from
$\sigma_0$.

\begin{enumerate}

\item Declare a register buffer. \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+}

\item Declare a variable to hold the address of the kernel
  information page (the type {\footnotesize\verb+l4_kernel_info+} is defined in
  {\footnotesize\verb+sigma0.h+}). \\ \\
  \hspace*{10pt} {\footnotesize\verb+l4_kernel_info *kinfo;+}
  
\item Provide the correct invalid address as the first register word.
  The constant {\footnotesize\verb+SIGMA0_KERNEL_INFO_MAP+} defined in {\footnotesize\verb+sigma0.h+}
  can be used for this purpose.
  \\ \\  \hspace*{10pt} {\footnotesize\verb+msg.reg[0] = SIGMA0_KERNEL_INFO_MAP;+} \\
  
\item RPC the request to $\sigma0$. \\ \\
  \hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_call(SIGMA0_TID, L4_IPC_SHORT_MSG, &msg,+}\\
  \hspace*{110pt} {\footnotesize\verb+L4_IPC_MAPMSG(0, L4_WHOLE_ADDRESS_SPACE),+}\\
  \hspace*{110pt} {\footnotesize\verb+&msg, L4_IPC_NEVER, &result);+} \\ \\
  Note that {\footnotesize\verb+L4_IPC_MAPMSG+} is a macro (defined in {\footnotesize\verb+ipc.h+})
  that can be used to construct receive descriptors for short fpage IPCs.
  
\item Store the address of the kernel information page returned by
  $\sigma_0$. \\ \\
  \hspace*{20pt} {\footnotesize\verb+kinfo = (l4_kernel_info *) msg.reg[0];+}

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{DIT Header page}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

$\sigma_0$ also supports multiple mappings of the DIT header page to
multiple requesters. A request for the DIT header page is made by
providing the DIT header address (obtained from the kernel information
page) as the first register word in a short IPC message to $\sigma_0$.

\begin{tabular}{ll}
\emph{msg.w0} (\reg{s0}) & \cbox{dit header address}{64}{32}\\
\emph{msg.w1} (\reg{s1}) & \cbox{\undef}{64}{32}\\
\end{tabular}
\vspace{1ex}

$\sigma_0$ will respond to a request in the above format by mapping the DIT header page read-only to the requester.  \\

\example{Accessing the DIT Header Page}

This example illustrates how information from the DIT header page can
be obtained. Assuming that the kernel information page has already
been mapped (see previous example) there are two ways to access the
DIT header page:

\begin{itemize}

\item Explicitly request a mapping of the DIT header page from
  $\sigma_0$ before accessing it.

\item Access the DIT header page without an explicit mapping. This
  works because accessing the DIT header page will cause a page fault
  if it has not already been mapped into the task's address space.
  $\sigma_0$ handles the page fault (since the task must be within
  $\sigma_0$'s clan otherwise it can't IPC to $\sigma_0$ anyway) by
  mapping the DIT header page into the faulter's address space.

\end{itemize}

The second method is simpler. The following example uses this method
to access the DIT header page and subsequently each file header.

\begin{enumerate}

\item Declare a variable to hold the address of the DIT header page
  and another variable to hold the address of a file header (the types
  {\footnotesize\verb+Dit_Dhdr+} and {\footnotesize\verb+Dit_Phdr+} are defined in {\footnotesize\verb+dit.h+}).\\ \\
  \hspace*{20pt} {\footnotesize\verb+Dit_Dhr dhdr;+} \\
  \hspace*{20pt} {\footnotesize\verb+Dit_Phdr phdr;+}
  
\item Assign the address of the DIT header page (from the already
  mapped kernel information page - see previous example) to the
  corresponding variable. \\ \\
  \hspace*{20pt} {\footnotesize\verb+dhdr = (Dit_Dhdr *) (kinfo -> dit_hdr);+}
  
\item Assign the address of the first file header to the corresponding
  variable. This address can be calculated by using the file header
  offset found in the DIT header page. \\ \\
  \hspace*{20pt} \verb`phdr = (Dit_Phdr *) ((int) dhdr + dhdr->d_phoff);`
  
\item Cycle through each of the file headers. Recall that the number
  of file headers is also given in the DIT header page. \\ \\
  \hspace*{20pt} \verb`for(i = 0; i < dhdr->d_phnum; i++, phdr++)` \\
  \hspace*{20pt} {\footnotesize\verb+{+} \\
    \hspace*{50pt} {\footnotesize\verb+/* do some work */+} \\
    \hspace*{85pt} \vdots \\
    \hspace*{20pt} {\footnotesize\verb+}+}

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Devices}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

A request for a device mapping can be made by providing a particular
invalid address (-2 on MIPS) as the first register word and the device
address as the second register word in a short IPC to $\sigma_0$.
Device addresses are identified by values outside the RAM range.

\begin{tabular}{ll}
\emph{msg.w0} (\reg{s0}) & \cbox{0xFFFFFFFFFFFFFFFE}{64}{32}\\
\emph{msg.w1} (\reg{s1}) & \cbox{address}{64}{32}\\
\end{tabular}
\vspace{1ex}

$\sigma_0$ will respond by mapping \emph{address} writable and
uncacheable to the requester.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\label{s:pf}Page Fault Handling}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:pf}

A page fault occurs when a task tries to access (read from or write
to) memory that has not already been mapped into its virtual address
space. A pager is a thread that handles page faults by determining the
actions to be taken in the event of a page fault (usually give a
mapping for the faulting address to the faulter).

When a new task/thread is created, a pager is registered with that
task/thread. The registered pager is then responsible for handling all
the thread's page faults. When a client thread triggers a page fault,
the L4 kernel intercepts the interrupt and sends an RPC to the pager
on the client's behalf. That is, the kernel sends the client's
faulting address and instruction pointer in the first two words of a
short IPC message to the registered pager pretending that the IPC
actually comes from the faulting thread. \\ 

\begin{param}{}
            w0 (\reg{s0})     &  \cbox{fault address / 4}{62}{30}\abox{$w$}{1}\abox{\undef}{1}\\
%
            w1 (\reg{s1})     &  \cbox{faulting user-level IP}{64}{32}\\[12pt]
%
            $w\,\EQ\,0$  &  Read page fault.\\
            $w\,\EQ\,1$  &  Write page fault.
\end{param}

The pager will receive the page fault message as if it were directly
from the faulter. It can then respond by sending an fpage mapping for
the faulting address back to the faulter\footnote{This is standard
  page fault handling but a pager may implement an arbitrary policy,
  in particular, kill any clients that attempt an invalid page
  access.}. The client does not actually receive the pager's mapping
as the mapping is intercepted by the kernel on the client's behalf.
The kernel restarts the client with the new mapping in place.

Figure~\ref{fig:l4-pf} illustrates the RPC paging protocol described. \\

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/l4-pf.eps}
\end{center}
\caption{Page Fault RPC}
\label{fig:l4-pf}
\end{figure}

$\sigma_0$ (see Section~\ref{sec:sigma0}) is an example of a pager
service. It is in fact the root pager because it handles the initial
address space and all mappings can be traced back to $\sigma_0$. The
other type of pagers which stem from $\sigma_0$ are the \emph{external
  pagers}. External pagers are user level threads which perform the
task of page fault handling for other threads. External pagers
themselves originally obtain their mappings from either $\sigma_0$ or
from an intermediate pager (which is just another external pager - see
Figure~\ref{fig:sigma0}).

A pager may send more than one page at a time, this allows implementing
pre-paging.

The \micro-kernel will ignore any attempts to map a page over an
already existing mapping, any existing mapping must first be removed
(e.g.\ by using an {\footnotesize\verb+le_fpage_unmap+} system call). An exception is
an attempt to replace an existing mapping by a mapping to the same
frame. In this case, the write-protection attribute of the mapping is
taken from the present IPC operation (the \(w\)-bit in the send fpage,
see Section~\ref{s:w-bit}). This allows the pager to change the
mapping between read-only and writable.

\example{A Simple Pager}

This example presents the basic tasks that a simple user level pager
needs to perform.

\begin{enumerate}

\item Assume the following declarations. \\ \\
  \hspace*{20pt} {\footnotesize\verb+int r;+}\\
  \hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+}\\
  \hspace*{20pt} {\footnotesize\verb+l4_threadid_t thrdid;+}\\
  \hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+}\\
  \hspace*{20pt} {\footnotesize\verb+dword_t fault_addr;+}\\
  \hspace*{20pt} {\footnotesize\verb+l4_snd_fpage_t *fp;+}

\item First, the pager needs to wait for a page fault message from
  any client. \\ \\
  \hspace*{20pt} {\footnotesize\verb+r = l4_mips_ipc_wait(&thrdid, L4_IPC_SHORT_MSG, &msg,+}\\
  \hspace*{130pt} {\footnotesize\verb+L4_IPC_NEVER, &result);+} \\ \\
  The faulter is recorded as the sender of the message (in {\footnotesize\verb+thrdid+})
  and the faulting address in the first word of the register buffer.
  
\item The pager now needs to obtain a mapping of the faulting
  address for itself (if it does not already have it) before it can
  pass the mapping on to the faulter. For this example, assume the pager
  gets its mappings from $\sigma_0$. \\ \\
  \hspace*{20pt} {\footnotesize\verb+fault_addr = (msg.reg[0] & (~(dword_t) 3)); /* mask out lower bits */+}\\
  \hspace*{20pt} {\footnotesize\verb+msg.reg[0] = fault_addr | 2; /* request write mapping */+}\\ \\
  \hspace*{20pt} {\footnotesize\verb+r = l4_mips_ipc_call(SIGMA0_TID, L4_IPC_SHORT_MSG, &msg,+}\\
  \hspace*{130pt} {\footnotesize\verb+L4_IPC_MAPMSG(0, L4_WHOLE_ADDRESS_SPACE),+}\\
  \hspace*{130pt} {\footnotesize\verb+&msg, L4_IPC_NEVER, &result);+}
  
\item Construct the send fpage descriptor for the  mapping to the
  faulting client. The single mapping to be sent is the same size as the
  single hardware page ($s$ = 12) and has the fault address as the send
  fpage base ($b$ = fault address) and also the hot spot. Note that the
  function {\footnotesize\verb+l4_fpage+} (defined in {\footnotesize\verb+types.h+}) can be used to
  construct an fpage. \\ \\
  \hspace*{20pt} {\footnotesize\verb+fp = (l4_snd_fpage_t *) &msg.reg[0];+} \\
  \hspace*{20pt} {\footnotesize\verb+fp[0].snd_base = fault_addr;+}\\
  \hspace*{20pt} {\footnotesize\verb+fp[0].fpage = l4_fpage(fault_addr, 12, 1, 0);+}\\
  \hspace*{20pt} {\footnotesize\verb+fp[1].fpage.fpage = 0; /* invalid fpage as a terminator */+}
  
\item Finally, send the mapping to the client. \\ \\
  \hspace*{20pt} {\footnotesize\verb+r = l4_mips_ipc_send(thrdid, L4_IPC_SHORT_FPAGE, &msg,+}\\
  \hspace*{130pt} {\footnotesize\verb+L4_IPC_NEVER, &result);+}
  
\item The pager returns to the start to wait for the next client
  page fault.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Exception And Interrupt Handling}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Exception Handling}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Exceptions are handled in a similar fashion to page faults (on
L4/MIPS). As with registering pagers, when a new task/thread is
created, an exception handler thread is also registered with it. When
a thread raises an exception, the kernel's interrupt handler sends an
RPC to the thread's registered exception handler. The protocol is
similar to that depicted in Figure~\ref{fig:l4-pf}. The exception
handler can choose to continue the thread that raised the exception by
replying to the message. Ignoring the IPC will block the faulting
thread forever and thus effectively kill it.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Interrupt Handling}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:interrupts}

A thread can install itself as an interrupt handler for a particular
interrupt by associating itself with the interrupt. A thread that
wants to associate itself with an interrupt needs to invoke a
\emph{receive} IPC specifying the interrupt number as the sender
(\emph{src} parameter) and a zero timeout. That is: \\ 

\hspace*{20pt} {\footnotesize\verb+l4_threadid_t sender;+} \\
\hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
\hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+}\\ \\
\hspace*{20pt} {\footnotesize\verb+sender = +} \ldots {\footnotesize\verb+; /* interrupt number */+}\\
\hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_receive(sender, L4_IPC_SHORT_MSG, &msg,+}\\
\hspace*{126pt} {\footnotesize\verb+L4_IPC_TIMEOUT(0, 0, 0, 1, 0, 0), &result);+}\\

Each interrupt is assigned to the first thread that attempts to
associate with it. Any attempt to associate with an already associated
interrupt will fail. A thread can dissociate itself as a handler for
an interrupt by associating with a NULL interrupt.

Once associated with an interrupt, a handler waits for interrupts by
receiving with non-zero timeout.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{OS On L4}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

This section discusses some of the basic issues and concepts that need
to be considered when creating an OS with L4 as the base.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\label{s:u:osstruct}OS Structure}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

The \micro-kernel concept logically leans towards a client-server OS
model. The OS provides servers that perform the required operations
upon request from clients (the pager is an example of this - see
Section~\ref{sec:pf}). Each OS server and the entire OS itself are in
fact operating at user level (same as the client). As such, multiple
\emph{OS personalities} can exist simultaneously without affecting
each other. Figure~\ref{fig:l4-os} shows a typical L4-based OS
structure.\\ 

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .7\textwidth
\epsfbox{eps/l4-os.eps}
\end{center}
\caption{Typical L4-based OS Structure}
\label{fig:l4-os}
\end{figure}

In L4 terms, an OS may consist of many server threads in the same or
separate tasks (i.e. single or multiple task OS). One of the OS tasks
will start up client processes making the OS chief of each of the
client processes.  Clients then make ``system calls'' via library
stubs which actually perform RPC to an OS server. The OS server may
choose to service the request itself or can redirect the request to
another OS server within or outside of its own task.

For example, the OS may contain a system call handler server which
makes use of RPC redirection.  The steps involved in a single client
system call would then be:

\begin{enumerate}

\item The client uses the library stub to send an RPC to the system
  call server and waits for a reply.

\item System call server forwards the request to another server via a
  \emph{deceiving} send IPC operation giving the client id as the
  virtual sender.

\item The subsystem performs the necessary operation and replies
  directly back to the client via a \emph{deceiving} send IPC
  operation giving the system call id as the virtual sender.

\item The client receives the reply to the original request as if it
  came directly from the system call server.

\end{enumerate}

Steps 2 and 3 above uses deceiving IPC to maintain RPC semantics.
Figure~\ref{fig:l4-redir} illustrates this RPC redirection procedure.
\\ 

\begin{figure}[h]
\begin{center}
\leavevmode
\epsfxsize = .5\textwidth
\epsfbox{eps/l4-redir.eps}
\end{center}
\caption{RPC Redirection}
\label{fig:l4-redir}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Some Conventions}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{OS Startup}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

When the OS first starts, there are a few recommended tasks that it
should perform before starting any client processes. Basically, the OS
needs to acquire all resources which are allocated on a first request
basis (to ensure resource control and prevent loss of resources to
clients) as well as set up the necessary structures. The tasks the OS
should perform on startup include:

\begin{itemize}

\item Register for all free interrupts.

\item Request all free memory from $\sigma_0$.

\item Request all pages containing device addresses (unless these are
  requested by separate driver tasks, which must then also be initial
  servers)

\item Set up data structures for memory management (reserve space for
  free lists, frame table, client page tables etc.)

\item Acquire all inactive tasks (i.e.\ use {\footnotesize\verb+l4_task_new+} on all
  inactive task IDs).

\item Start other server threads (if any).

\item Start device driver threads (if any).

\item Set up service data structures (i.e. TCBs, file system, etc.).

\end{itemize}

After the OS has completed all the preliminary tasks, it can start up
one or many client tasks. The OS may choose to donate some of its
acquired tasks to any of the user (sub)tasks.

Note that the OS itself is just a user level L4 task and thus can be
interrupted and scheduled out. This fact, together with
multi-threading, makes it essential to have concurrency control on all
OS data structures.

Initial servers are started up by L4 and therefore cannot receive a
stack address from their parent. They must therefore initialise their
own stack. This is normally done by using special startup code for
initial servers (``crtS'') which initialises the stack pointer to the
top of a static array.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Clients}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

After start up, the OS will be either waiting for a client request or
actually handling a client request. After the preliminaries, it is the
job of the OS to start the client tasks (else the OS will have nothing
to do!). But where does the OS look to find clients to start? The
answer is that it is a matter of convention and is decided by the OS
designer. Some common options are:

\begin{itemize}

\item OS starts up first non-initial server executable in the boot
  image. (Recall that the files section of the boot image is composed
  of initial servers followed by other data - see
  Figure~\ref{fig:dit}.  Non-initial servers are part of the other
  data).

\item First non-executable item in the boot image contains a list of
  initial client tasks.

\item The OS looks for an executable with a predefined name in the
  boot image.

\end{itemize}

After the client has been started, it will want to make system calls
as a normal part of its operations. Again, there needs to be some
convention defined to let clients know where to send their system call
RPCs (i.e.\ need to know id of OS's system call server). Some common
options are:

\begin{itemize}

\item First thing the client does is an open receive. The OS (or any
  other task that started the client) follows the protocol by sending
  a message to the client containing its own identity or the identity
  of another server. Note that this client startup protocol can be
  hidden in startup code (``crt0'').

\item Client could send all system call RPCs to $\sigma_0$. Then the
  clans and chiefs mechanism will ensure that the chief of the client
  task will intercept the message. The chief can then reply pretending
  to be $\sigma_0$ via a deceiving send IPC.\\ 

\end{itemize}

\example{Client Startup Protocol}

This example illustrates one way in which the OS can disclose the
identity of its system call server id to client tasks. \\ \\ 

\hspace*{10pt} OS code fragment: \\ \\
\hspace*{50pt} \vdots \\
\hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
\hspace*{20pt} {\footnotesize\verb+l4_msg_dope_t result;+} \\
\hspace*{20pt} {\footnotesize\verb+l4_threadid_t subid, syscallid;+} \\ \\
\hspace*{20pt} {\footnotesize\verb+syscallid = +} \ldots {\footnotesize\verb+; /* system call server id */+} \\
\hspace*{20pt} {\footnotesize\verb+subid = l4_task_new(+} \ldots {\footnotesize\verb+); /* start the client task */+} \\ \\
\hspace*{30pt} {\footnotesize\verb+ /* Send system call server id to the new client */+} \\
\hspace*{20pt} {\footnotesize\verb+ msg.reg[0] = syscallid.ID;+} \\
\hspace*{20pt} {\footnotesize\verb+ l4_mips_ipc_send(subid, L4_IPC_SHORT_MSG, &msg, L4_IPC_NEVER, &result);+} \\
\hspace*{50pt} \vdots \\ \\

\hspace*{10pt} Client code fragment: \\ \\
\hspace*{20pt} {\footnotesize\verb+l4_ipc_reg_msg_t msg;+} \\
\hspace*{20pt} {\footnotesize\verb+l4_msgdope_t result;+} \\
\hspace*{20pt} {\footnotesize\verb+l4_threadid_t OSid, syscallid;+} \\ \\
\hspace*{30pt} {\footnotesize\verb+/* Wait for message from OS */+} \\
\hspace*{20pt} {\footnotesize\verb+l4_mips_ipc_wait(&OSid, L4_IPC_SHORT_MSG, &msg, L4_IPC_NEVER, &result);+} \\ \\
\hspace*{30pt} {\footnotesize\verb+/* Store system call server id from message */+} \\
\hspace*{20pt} {\footnotesize\verb+syscallid = (l4_threadid_t) msg.reg[0];+} \\
\hspace*{50pt} \vdots \\

Note that the client gets both the id of the OS (implicitly - as the
sender in the open receive) and the system call server id (explicitly
- as part of the message).

% 
%%% Local Variables: %%%
%%% mode: latex %%%
%%% End: %%%
